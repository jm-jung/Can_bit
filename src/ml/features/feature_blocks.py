"""
Modular feature blocks for ML pipeline.

Phase E: Structural improvements - Feature pipeline refactoring.

Each feature block is a self-contained module that:
- Adds features to a DataFrame
- Returns a list of feature names it generated
- Can be enabled/disabled independently
"""
from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from typing import List

import numpy as np
import pandas as pd

from src.core.config import settings
from src.events.aggregator import build_event_feature_frame
from src.features.extended_features import (
    build_extended_trend_features,
    build_structure_features,
    build_volatility_features,
    build_volume_features,
)
from src.indicators.basic import add_basic_indicators

logger = logging.getLogger(__name__)


class FeatureBlock(ABC):
    """Base class for feature blocks."""
    
    def __init__(self, name: str):
        """
        Initialize feature block.
        
        Args:
            name: Block name (e.g., "BaseFeatures", "TrendFeatures")
        """
        self.name = name
        self._feature_list: List[str] = []
    
    @abstractmethod
    def add_features(self, df: pd.DataFrame, **kwargs) -> pd.DataFrame:
        """
        Add features to DataFrame.
        
        Args:
            df: Input DataFrame with OHLCV + indicators
            **kwargs: Additional parameters (symbol, timeframe, etc.)
        
        Returns:
            DataFrame with added features
        """
        pass
    
    def list_features(self) -> List[str]:
        """
        Return list of feature names generated by this block.
        
        Returns:
            List of feature column names
        """
        return self._feature_list.copy()
    
    def _register_feature(self, feature_name: str) -> None:
        """Register a feature name."""
        if feature_name not in self._feature_list:
            self._feature_list.append(feature_name)


class BaseFeatureBlock(FeatureBlock):
    """Base OHLCV and indicator features."""
    
    def __init__(self):
        super().__init__("BaseFeatures")
    
    def add_features(self, df: pd.DataFrame, **kwargs) -> pd.DataFrame:
        """
        Add base technical features.
        
        Features:
        - OHLCV: close, high, low, volume
        - Price-derived: high_low, close_open, close_open_pct
        - Indicators: ema_20, sma_20, rsi_14
        - Rolling stats: rolling_std_20, rolling_mean_20
        - Ratios: close_ema_ratio, close_sma_ratio
        """
        if df.index is None or len(df.index) == 0:
            raise ValueError("Input DataFrame must have a valid index")
        
        # Ensure indicators are calculated
        if "ema_20" not in df.columns or "sma_20" not in df.columns or "rsi_14" not in df.columns:
            df = add_basic_indicators(df)
        
        features = pd.DataFrame(index=df.index)
        
        # Basic OHLCV features
        features["close"] = df["close"]
        features["high"] = df["high"]
        features["low"] = df["low"]
        features["volume"] = df["volume"]
        
        # Price-derived features
        features["high_low"] = df["high"] - df["low"]
        features["close_open"] = df["close"] - df["open"]
        open_nonzero = df["open"].replace(0.0, np.nan)
        close_open_pct = features["close_open"] / open_nonzero
        features["close_open_pct"] = close_open_pct.fillna(0.0)
        
        # Indicators
        features["ema_20"] = df["ema_20"]
        features["sma_20"] = df["sma_20"]
        features["rsi_14"] = df["rsi_14"]
        
        # Rolling statistics
        features["rolling_std_20"] = df["close"].rolling(window=20, min_periods=1).std()
        features["rolling_mean_20"] = df["close"].rolling(window=20, min_periods=1).mean()
        
        # Ratios
        ema_nonzero = df["ema_20"].replace(0.0, np.nan)
        sma_nonzero = df["sma_20"].replace(0.0, np.nan)
        features["close_ema_ratio"] = (df["close"] / ema_nonzero).replace([np.inf, -np.inf], np.nan)
        features["close_sma_ratio"] = (df["close"] / sma_nonzero).replace([np.inf, -np.inf], np.nan)
        
        # Register features
        self._feature_list = list(features.columns)
        
        # Replace inf/-inf with NaN
        features = features.replace([np.inf, -np.inf], np.nan)
        
        return features


class TrendFeatureBlock(FeatureBlock):
    """Extended trend features."""
    
    def __init__(self):
        super().__init__("TrendFeatures")
    
    def add_features(self, df: pd.DataFrame, **kwargs) -> pd.DataFrame:
        """
        Add extended trend features.
        
        Features:
        - Log returns (1, 3, 5 periods)
        - Distance from EMA/SMA (normalized)
        - EMA/SMA ratios
        - Trend slopes
        """
        features = build_extended_trend_features(df)
        self._feature_list = list(features.columns)
        return features


class VolatilityFeatureBlock(FeatureBlock):
    """Volatility features."""
    
    def __init__(self):
        super().__init__("VolatilityFeatures")
    
    def add_features(self, df: pd.DataFrame, **kwargs) -> pd.DataFrame:
        """
        Add volatility features.
        
        Features:
        - True Range (TR)
        - Average True Range (ATR)
        - Normalized ATR
        - Return volatility (rolling std)
        - High-low range (normalized)
        """
        features = build_volatility_features(df)
        self._feature_list = list(features.columns)
        return features


class VolumeFeatureBlock(FeatureBlock):
    """Volume-based features."""
    
    def __init__(self):
        super().__init__("VolumeFeatures")
    
    def add_features(self, df: pd.DataFrame, **kwargs) -> pd.DataFrame:
        """
        Add volume features.
        
        Features:
        - Volume moving average
        - Volume z-score
        - Volume ratio (short-term vs long-term)
        """
        features = build_volume_features(df)
        self._feature_list = list(features.columns)
        return features


class StructureFeatureBlock(FeatureBlock):
    """Candle structure features."""
    
    def __init__(self):
        super().__init__("StructureFeatures")
    
    def add_features(self, df: pd.DataFrame, **kwargs) -> pd.DataFrame:
        """
        Add structure features.
        
        Features:
        - Body size and ratios
        - Upper/lower shadow ratios
        - Direction counts (up/down bars)
        """
        features = build_structure_features(df)
        self._feature_list = list(features.columns)
        return features


class EventFeatureBlock(FeatureBlock):
    """Event-based features."""
    
    def __init__(self):
        super().__init__("EventFeatures")
    
    def add_features(
        self,
        df: pd.DataFrame,
        symbol: str = "BTCUSDT",
        timeframe: str = "1m",
        event_lookback_minutes: int | None = None,
        **kwargs,
    ) -> pd.DataFrame:
        """
        Add event features.
        
        Features:
        - Event counts
        - Event sentiment scores
        - Event aggregations over lookback window
        
        Args:
            df: OHLCV DataFrame
            symbol: Trading symbol
            timeframe: Timeframe
            event_lookback_minutes: Lookback window for event aggregation
        """
        if event_lookback_minutes is None:
            event_lookback_minutes = settings.EVENTS_LOOKBACK_MINUTES
        
        event_df = build_event_feature_frame(
            ohlcv_df=df,
            symbol=symbol,
            timeframe=timeframe,
            lookback_minutes=event_lookback_minutes,
        )
        
        if event_df is not None and len(event_df.columns) > 0:
            self._feature_list = list(event_df.columns)
        else:
            self._feature_list = []
            event_df = pd.DataFrame(index=df.index)
        
        return event_df


class RegimeFeatureBlock(FeatureBlock):
    """Volatility regime features (Phase E)."""
    
    def __init__(self, atr_percentile_threshold: float = 0.70):
        """
        Initialize regime feature block.
        
        Args:
            atr_percentile_threshold: Percentile threshold for HIGH_VOL classification (default: 0.70)
        """
        super().__init__("RegimeFeatures")
        self.atr_percentile_threshold = atr_percentile_threshold
    
    def add_features(self, df: pd.DataFrame, **kwargs) -> pd.DataFrame:
        """
        Add volatility regime features.
        
        Features:
        - regime_label: "HIGH_VOL" or "LOW_VOL" (based on ATR percentile)
        - regime_high_vol: Binary indicator (1 if HIGH_VOL, 0 otherwise)
        - regime_low_vol: Binary indicator (1 if LOW_VOL, 0 otherwise)
        - atr_percentile: Current ATR percentile (0-1)
        
        Args:
            df: DataFrame with OHLCV (must have high, low, close for ATR calculation)
        """
        if df.index is None or len(df.index) == 0:
            raise ValueError("Input DataFrame must have a valid index")
        
        features = pd.DataFrame(index=df.index)
        
        # Calculate ATR if not present
        if "atr_14" not in df.columns:
            # Compute True Range
            high_low = df["high"] - df["low"]
            high_prev_close = abs(df["high"] - df["close"].shift(1))
            low_prev_close = abs(df["low"] - df["close"].shift(1))
            tr = pd.concat([high_low, high_prev_close, low_prev_close], axis=1).max(axis=1)
            atr = tr.rolling(window=14, min_periods=1).mean()
        else:
            atr = df["atr_14"]
        
        # Calculate rolling percentile (100-period window)
        atr_percentile = atr.rolling(window=100, min_periods=1).apply(
            lambda x: (x.iloc[-1] >= x.quantile(self.atr_percentile_threshold))
        )
        
        # Regime labels
        features["regime_label"] = pd.Series(index=df.index, dtype=str)
        features.loc[atr_percentile >= self.atr_percentile_threshold, "regime_label"] = "HIGH_VOL"
        features.loc[atr_percentile < self.atr_percentile_threshold, "regime_label"] = "LOW_VOL"
        
        # Binary indicators
        features["regime_high_vol"] = (features["regime_label"] == "HIGH_VOL").astype(int)
        features["regime_low_vol"] = (features["regime_label"] == "LOW_VOL").astype(int)
        
        # ATR percentile (0-1)
        features["atr_percentile"] = atr_percentile.fillna(0.5)
        
        # Register features
        self._feature_list = list(features.columns)
        
        return features
    
    def get_regime_labels(self, df: pd.DataFrame) -> pd.Series:
        """
        Extract regime labels from DataFrame (must have been processed by add_features).
        
        Args:
            df: DataFrame with regime features
        
        Returns:
            Series with "HIGH_VOL" or "LOW_VOL" labels
        """
        if "regime_label" not in df.columns:
            raise ValueError("DataFrame must contain regime_label column. Call add_features first.")
        return df["regime_label"]


class FeatureBlockManager:
    """Manager for feature blocks."""
    
    def __init__(
        self,
        use_base: bool = True,
        use_trend: bool = False,
        use_volatility: bool = False,
        use_volume: bool = False,
        use_structure: bool = False,
        use_events: bool = False,
        use_regime: bool = False,
        atr_percentile_threshold: float = 0.70,
    ):
        """
        Initialize feature block manager.
        
        Args:
            use_base: Enable base features
            use_trend: Enable trend features
            use_volatility: Enable volatility features
            use_volume: Enable volume features
            use_structure: Enable structure features
            use_events: Enable event features
            use_regime: Enable regime features
            atr_percentile_threshold: ATR percentile threshold for regime classification
        """
        self.blocks: List[FeatureBlock] = []
        
        if use_base:
            self.blocks.append(BaseFeatureBlock())
        if use_trend:
            self.blocks.append(TrendFeatureBlock())
        if use_volatility:
            self.blocks.append(VolatilityFeatureBlock())
        if use_volume:
            self.blocks.append(VolumeFeatureBlock())
        if use_structure:
            self.blocks.append(StructureFeatureBlock())
        if use_events:
            self.blocks.append(EventFeatureBlock())
        if use_regime:
            self.blocks.append(RegimeFeatureBlock(atr_percentile_threshold=atr_percentile_threshold))
        
        logger.info(f"[FeatureBlockManager] Initialized with {len(self.blocks)} blocks: {[b.name for b in self.blocks]}")
    
    def build_features(self, df: pd.DataFrame, **kwargs) -> tuple[pd.DataFrame, List[str]]:
        """
        Build features using all enabled blocks.
        
        Args:
            df: Input DataFrame with OHLCV
            **kwargs: Additional parameters (symbol, timeframe, etc.)
        
        Returns:
            Tuple of (feature DataFrame, list of feature names)
        """
        if len(self.blocks) == 0:
            logger.warning("[FeatureBlockManager] No feature blocks enabled. Returning empty DataFrame.")
            return pd.DataFrame(index=df.index), []
        
        feature_frames = []
        all_feature_names = []
        
        for block in self.blocks:
            try:
                block_features = block.add_features(df, **kwargs)
                block_feature_names = block.list_features()
                
                if len(block_feature_names) > 0:
                    feature_frames.append(block_features)
                    all_feature_names.extend(block_feature_names)
                    logger.debug(f"[FeatureBlockManager] {block.name}: added {len(block_feature_names)} features")
            except Exception as e:
                logger.warning(f"[FeatureBlockManager] Failed to add features from {block.name}: {e}")
                continue
        
        if feature_frames:
            feature_df = pd.concat(feature_frames, axis=1)
        else:
            feature_df = pd.DataFrame(index=df.index)
        
        # Replace inf/-inf with NaN, then fill with 0
        feature_df = feature_df.replace([np.inf, -np.inf], np.nan)
        feature_df = feature_df.fillna(0.0)
        
        logger.info(f"[FeatureBlockManager] Built {len(all_feature_names)} features from {len(self.blocks)} blocks")
        
        return feature_df, all_feature_names
    
    def list_all_features(self) -> List[str]:
        """
        List all feature names that would be generated.
        
        Returns:
            List of feature names
        """
        all_features = []
        for block in self.blocks:
            all_features.extend(block.list_features())
        return all_features

